<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Horiba U-5000 Auto Baud Finder</title>
<style>
body { font-family: system-ui,sans-serif; max-width: 800px; padding: 1rem; }
button,input { margin: 0.25rem 0; display: block; }
textarea { width: 100%; height: 300px; font-family: monospace; white-space: pre; }
</style>
</head>
<body>
<h1>Horiba U-5000 Auto Baud Finder</h1>
<p>Automatically scans baud rates and logs any data received.</p>

<button id="connectBtn">Connect to Device</button>
<button id="startBtn" disabled>Start Auto Scan</button>
<button id="stopBtn" disabled>Stop</button>
<button id="downloadBtn" disabled>Download Log (CSV)</button>

<textarea id="log" readonly placeholder="Log will appear here..."></textarea>

<script>
const connectBtn = document.getElementById('connectBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const downloadBtn = document.getElementById('downloadBtn');
const logArea = document.getElementById('log');

let port = null;
let reader = null;
let keepRunning = false;
let dataLog = [];

function appendLine(line){
    logArea.value += line + '\n';
    logArea.scrollTop = logArea.scrollHeight;
    if(line.trim()) dataLog.push('"' + line.replace(/"/g,'""') + '"');
}

// Build request command with XOR FCS
function calcFCS(str){
    let xor = 0;
    for(let i=0;i<str.length;i++) xor ^= str.charCodeAt(i);
    let hex = xor.toString(16).toUpperCase();
    return hex.length<2 ? '0'+hex : hex;
}
function buildRequest(){
    const header = "#RD@";
    const fcs = calcFCS(header);
    return header + fcs + '\r\n';
}

// Open port
async function openPort(baud){
    try{
        await port.open({baudRate:baud,dataBits:8,stopBits:1,parity:'none',flowControl:'none'});
        appendLine(`Port opened at ${baud}`);
        return true;
    }catch(e){ appendLine(`Failed to open ${baud}: ${e}`); return false; }
}

// Close port
async function closePort(){
    try{
        if(reader){ await reader.cancel(); reader=null; }
        if(port && port.readable){ await port.close(); appendLine('Port closed'); }
    }catch(e){ appendLine('Close error: '+e); }
}

// Read data for given timeout (ms)
async function readOnce(timeout=2000){
    const textDecoder = new TextDecoderStream();
    port.readable.pipeTo(textDecoder.writable);
    reader = textDecoder.readable.getReader();
    const start = Date.now();
    let buffer = '';
    while(Date.now()-start<timeout){
        try{
            const {value,done} = await reader.read();
            if(done) break;
            if(value) buffer += value;
        }catch(e){
            appendLine('Read error: '+e);
            break;
        }
    }
    if(reader){ try{ await reader.cancel(); }catch{} reader=null; }
    return buffer;
}

// Main auto-scan
async function autoScan(){
    if(!port) return appendLine('No port selected');
    keepRunning = true;
    const bauds = [19200,38400,57600,115200]; // likely Horiba baud rates
    appendLine('--- Auto Scan Started ---');

    for(let baud of bauds){
        if(!keepRunning) break;
        await closePort();
        const ok = await openPort(baud);
        if(!ok) continue;

        // Try reading first
        let resp = await readOnce(2000);
        if(!resp){
            // if no data, try sending request command
            const writer = port.writable.getWriter();
            const req = buildRequest();
            appendLine(`→ Sending request at ${baud}: ${req.trim()}`);
            await writer.write(new TextEncoder().encode(req));
            writer.releaseLock();
            resp = await readOnce(2000);
        }

        if(resp){
            appendLine(`<– Response at ${baud}: ${resp.replace(/\r/g,'\\r').replace(/\n/g,'\\n')}`);
        }else{
            appendLine(`<– No response at ${baud}`);
        }
    }

    await closePort();
    appendLine('--- Auto Scan Finished ---');
    downloadBtn.disabled = dataLog.length===0;
}

connectBtn.addEventListener('click', async ()=>{
    try{
        port = await navigator.serial.requestPort();
        appendLine('Port selected by user');
        startBtn.disabled = false;
    }catch(e){ appendLine('Port selection failed: '+e); }
});

startBtn.addEventListener('click', async ()=>{
    startBtn.disabled=true;
    stopBtn.disabled=false;
    dataLog=[];
    await autoScan();
    stopBtn.disabled=true;
    startBtn.disabled=false;
});

stopBtn.addEventListener('click', ()=>{ keepRunning=false; });

downloadBtn.addEventListener('click', ()=>{
    const csv = dataLog.join('\n');
    const blob = new Blob([csv],{type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url;
    a.download='horiba_u5000_log.csv';
    a.click();
    URL.revokeObjectURL(url);
});
</script>
</body>
</html>
